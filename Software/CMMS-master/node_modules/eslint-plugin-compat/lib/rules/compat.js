"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash.memoize"));

var _Lint = require("../Lint");

var _Versioning = _interopRequireWildcard(require("../Versioning"));

var _providers = require("../providers");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getName(node) {
  switch (node.type) {
    case 'NewExpression':
      {
        return node.callee.name;
      }

    case 'MemberExpression':
      {
        return node.object.name;
      }

    case 'CallExpression':
      {
        return node.callee.name;
      }

    default:
      throw new Error('not found');
  }
}

function generateErrorName(rule) {
  if (rule.name) return rule.name;
  if (rule.property) return `${rule.object}.${rule.property}()`;
  return rule.object;
}

const getPolyfillSet = (0, _lodash.default)(polyfillArrayJSON => new Set(JSON.parse(polyfillArrayJSON)));

function isPolyfilled(context, rule) {
  if (!context.settings.polyfills) return false;
  const polyfills = getPolyfillSet(JSON.stringify(context.settings.polyfills));
  return (// v2 allowed users to select polyfills based off their caniuseId. This is
    // no longer supported. Keeping this here to avoid breaking changes.
    polyfills.has(rule.id) || // Check if polyfill is provided (ex. `Promise.all`)
    polyfills.has(rule.protoChainId) || // Check if entire API is polyfilled (ex. `Promise`)
    polyfills.has(rule.protoChain[0])
  );
}

const getRulesForTargets = (0, _lodash.default)(targetsJSON => {
  const targets = JSON.parse(targetsJSON);
  const result = {
    CallExpression: [],
    NewExpression: [],
    MemberExpression: []
  };

  _providers.rules.forEach(rule => {
    if (rule.getUnsupportedTargets(rule, targets).length === 0) return;
    result[rule.astNodeType].push(rule);
  });

  return result;
});
var _default = {
  meta: {
    docs: {
      description: 'Ensure cross-browser API compatibility',
      category: 'Compatibility',
      url: 'https://github.com/amilajack/eslint-plugin-compat/blob/master/docs/rules/compat.md',
      recommended: true
    },
    fixable: 'code',
    schema: [{
      type: 'string'
    }]
  },

  create(context) {
    // Determine lowest targets from browserslist config, which reads user's
    // package.json config section. Use config from eslintrc for testing purposes
    const browserslistConfig = context.settings.browsers || context.settings.targets || context.options[0];
    const browserslistTargets = (0, _Versioning.Versioning)((0, _Versioning.default)(context.getFilename(), browserslistConfig)); // Stringify to support memoization; browserslistConfig is always an array of new objects.

    const targetedRules = getRulesForTargets(JSON.stringify(browserslistTargets));
    const errors = [];

    function handleFailingRule(rule, node) {
      if (isPolyfilled(context, rule)) return;
      errors.push({
        node,
        message: [generateErrorName(rule), 'is not supported in', rule.getUnsupportedTargets(rule, browserslistTargets).join(', ')].join(' ')
      });
    }

    const identifiers = new Set();
    return {
      CallExpression: _Lint.lintCallExpression.bind(null, handleFailingRule, targetedRules.CallExpression),
      NewExpression: _Lint.lintNewExpression.bind(null, handleFailingRule, targetedRules.NewExpression),
      MemberExpression: _Lint.lintMemberExpression.bind(null, handleFailingRule, targetedRules.MemberExpression),

      // Keep track of all the defined variables. Do not report errors for nodes that are not defined
      Identifier(node) {
        if (node.parent) {
          const {
            type
          } = node.parent;

          if ( // ex. const { Set } = require('immutable');
          type === 'Property' || // ex. function Set() {}
          type === 'FunctionDeclaration' || // ex. const Set = () => {}
          type === 'VariableDeclarator' || // ex. class Set {}
          type === 'ClassDeclaration' || // ex. import Set from 'set';
          type === 'ImportDefaultSpecifier' || // ex. import {Set} from 'set';
          type === 'ImportSpecifier' || // ex. import {Set} from 'set';
          type === 'ImportDeclaration') {
            identifiers.add(node.name);
          }
        }
      },

      'Program:exit': () => {
        // Get a map of all the variables defined in the root scope (not the global scope)
        // const variablesMap = context.getScope().childScopes.map(e => e.set)[0];
        errors.filter(error => !identifiers.has(getName(error.node))).forEach(node => context.report(node));
      }
    };
  }

};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ydWxlcy9jb21wYXQuanMiXSwibmFtZXMiOlsiZ2V0TmFtZSIsIm5vZGUiLCJ0eXBlIiwiY2FsbGVlIiwibmFtZSIsIm9iamVjdCIsIkVycm9yIiwiZ2VuZXJhdGVFcnJvck5hbWUiLCJydWxlIiwicHJvcGVydHkiLCJnZXRQb2x5ZmlsbFNldCIsInBvbHlmaWxsQXJyYXlKU09OIiwiU2V0IiwiSlNPTiIsInBhcnNlIiwiaXNQb2x5ZmlsbGVkIiwiY29udGV4dCIsInNldHRpbmdzIiwicG9seWZpbGxzIiwic3RyaW5naWZ5IiwiaGFzIiwiaWQiLCJwcm90b0NoYWluSWQiLCJwcm90b0NoYWluIiwiZ2V0UnVsZXNGb3JUYXJnZXRzIiwidGFyZ2V0c0pTT04iLCJ0YXJnZXRzIiwicmVzdWx0IiwiQ2FsbEV4cHJlc3Npb24iLCJOZXdFeHByZXNzaW9uIiwiTWVtYmVyRXhwcmVzc2lvbiIsInJ1bGVzIiwiZm9yRWFjaCIsImdldFVuc3VwcG9ydGVkVGFyZ2V0cyIsImxlbmd0aCIsImFzdE5vZGVUeXBlIiwicHVzaCIsIm1ldGEiLCJkb2NzIiwiZGVzY3JpcHRpb24iLCJjYXRlZ29yeSIsInVybCIsInJlY29tbWVuZGVkIiwiZml4YWJsZSIsInNjaGVtYSIsImNyZWF0ZSIsImJyb3dzZXJzbGlzdENvbmZpZyIsImJyb3dzZXJzIiwib3B0aW9ucyIsImJyb3dzZXJzbGlzdFRhcmdldHMiLCJnZXRGaWxlbmFtZSIsInRhcmdldGVkUnVsZXMiLCJlcnJvcnMiLCJoYW5kbGVGYWlsaW5nUnVsZSIsIm1lc3NhZ2UiLCJqb2luIiwiaWRlbnRpZmllcnMiLCJsaW50Q2FsbEV4cHJlc3Npb24iLCJiaW5kIiwibGludE5ld0V4cHJlc3Npb24iLCJsaW50TWVtYmVyRXhwcmVzc2lvbiIsIklkZW50aWZpZXIiLCJwYXJlbnQiLCJhZGQiLCJmaWx0ZXIiLCJlcnJvciIsInJlcG9ydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBOztBQUNBOztBQUtBOztBQUVB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YUFBYSxDQUFDdEIsYUFIRCxDQU5WO0FBV0xDLE1BQUFBLGdCQUFnQixFQUFFOEIsMkJBQXFCRixJQUFyQixDQUNoQixJQURnQixFQUVoQkwsaUJBRmdCLEVBR2hCRixhQUFhLENBQUNyQixnQkFIRSxDQVhiOztBQWdCTDtBQUNBK0IsTUFBQUEsVUFBVSxDQUFDNUQsSUFBRCxFQUFtQjtBQUMzQixZQUFJQSxJQUFJLENBQUM2RCxNQUFULEVBQWlCO0FBQ2YsZ0JBQU07QUFBRTVELFlBQUFBO0FBQUYsY0FBV0QsSUFBSSxDQUFDNkQsTUFBdEI7O0FBQ0EsZUFDRTtBQUNBNUQsVUFBQUEsSUFBSSxLQUFLLFVBQVQsSUFDQTtBQUNBQSxVQUFBQSxJQUFJLEtBQUsscUJBRlQsSUFHQTtBQUNBQSxVQUFBQSxJQUFJLEtBQUssb0JBSlQsSUFLQTtBQUNBQSxVQUFBQSxJQUFJLEtBQUssa0JBTlQsSUFPQTtBQUNBQSxVQUFBQSxJQUFJLEtBQUssd0JBUlQsSUFTQTtBQUNBQSxVQUFBQSxJQUFJLEtBQUssaUJBVlQsSUFXQTtBQUNBQSxVQUFBQSxJQUFJLEtBQUssbUJBZFgsRUFlRTtBQUNBc0QsWUFBQUEsV0FBVyxDQUFDTyxHQUFaLENBQWdCOUQsSUFBSSxDQUFDRyxJQUFyQjtBQUNEO0FBQ0Y7QUFDRixPQXZDSTs7QUF3Q0wsc0JBQWdCLE1BQU07QUFDcEI7QUFDQTtBQUNBZ0QsUUFBQUEsTUFBTSxDQUNIWSxNQURILENBQ1VDLEtBQUssSUFBSSxDQUFDVCxXQUFXLENBQUNwQyxHQUFaLENBQWdCcEIsT0FBTyxDQUFDaUUsS0FBSyxDQUFDaEUsSUFBUCxDQUF2QixDQURwQixFQUVHK0IsT0FGSCxDQUVXL0IsSUFBSSxJQUFJZSxPQUFPLENBQUNrRCxNQUFSLENBQWVqRSxJQUFmLENBRm5CO0FBR0Q7QUE5Q0ksS0FBUDtBQWdERDs7QUE3RlksQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdsb2Rhc2gubWVtb2l6ZSc7XG5pbXBvcnQge1xuICBsaW50Q2FsbEV4cHJlc3Npb24sXG4gIGxpbnRNZW1iZXJFeHByZXNzaW9uLFxuICBsaW50TmV3RXhwcmVzc2lvblxufSBmcm9tICcuLi9MaW50JztcbmltcG9ydCBEZXRlcm1pbmVUYXJnZXRzRnJvbUNvbmZpZywgeyBWZXJzaW9uaW5nIH0gZnJvbSAnLi4vVmVyc2lvbmluZyc7XG5pbXBvcnQgdHlwZSB7IEVTTGludE5vZGUsIE5vZGUsIEJyb3dzZXJMaXN0Q29uZmlnIH0gZnJvbSAnLi4vTGludFR5cGVzJztcbmltcG9ydCB7IHJ1bGVzIH0gZnJvbSAnLi4vcHJvdmlkZXJzJztcblxudHlwZSBFU0xpbnQgPSB7XG4gIFthc3ROb2RlVHlwZU5hbWU6IHN0cmluZ106IChub2RlOiBFU0xpbnROb2RlKSA9PiB2b2lkXG59O1xuXG50eXBlIENvbnRleHQgPSB7XG4gIG5vZGU6IEVTTGludE5vZGUsXG4gIG9wdGlvbnM6IEFycmF5PHN0cmluZz4sXG4gIHNldHRpbmdzOiB7XG4gICAgYnJvd3NlcnM6IEFycmF5PHN0cmluZz4sXG4gICAgcG9seWZpbGxzOiBBcnJheTxzdHJpbmc+XG4gIH0sXG4gIGdldEZpbGVuYW1lOiAoKSA9PiBzdHJpbmcsXG4gIHJlcG9ydDogKCkgPT4gdm9pZFxufTtcblxuZnVuY3Rpb24gZ2V0TmFtZShub2RlOiBFU0xpbnROb2RlKTogc3RyaW5nIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlICdOZXdFeHByZXNzaW9uJzoge1xuICAgICAgcmV0dXJuIG5vZGUuY2FsbGVlLm5hbWU7XG4gICAgfVxuICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOiB7XG4gICAgICByZXR1cm4gbm9kZS5vYmplY3QubmFtZTtcbiAgICB9XG4gICAgY2FzZSAnQ2FsbEV4cHJlc3Npb24nOiB7XG4gICAgICByZXR1cm4gbm9kZS5jYWxsZWUubmFtZTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGZvdW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvck5hbWUocnVsZTogTm9kZSk6IHN0cmluZyB7XG4gIGlmIChydWxlLm5hbWUpIHJldHVybiBydWxlLm5hbWU7XG4gIGlmIChydWxlLnByb3BlcnR5KSByZXR1cm4gYCR7cnVsZS5vYmplY3R9LiR7cnVsZS5wcm9wZXJ0eX0oKWA7XG4gIHJldHVybiBydWxlLm9iamVjdDtcbn1cblxuY29uc3QgZ2V0UG9seWZpbGxTZXQgPSBtZW1vaXplKFxuICAocG9seWZpbGxBcnJheUpTT046IHN0cmluZyk6IFNldDxTdHJpbmc+ID0+XG4gICAgbmV3IFNldChKU09OLnBhcnNlKHBvbHlmaWxsQXJyYXlKU09OKSlcbik7XG5cbmZ1bmN0aW9uIGlzUG9seWZpbGxlZChjb250ZXh0OiBDb250ZXh0LCBydWxlOiBOb2RlKTogYm9vbGVhbiB7XG4gIGlmICghY29udGV4dC5zZXR0aW5ncy5wb2x5ZmlsbHMpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcG9seWZpbGxzID0gZ2V0UG9seWZpbGxTZXQoSlNPTi5zdHJpbmdpZnkoY29udGV4dC5zZXR0aW5ncy5wb2x5ZmlsbHMpKTtcbiAgcmV0dXJuIChcbiAgICAvLyB2MiBhbGxvd2VkIHVzZXJzIHRvIHNlbGVjdCBwb2x5ZmlsbHMgYmFzZWQgb2ZmIHRoZWlyIGNhbml1c2VJZC4gVGhpcyBpc1xuICAgIC8vIG5vIGxvbmdlciBzdXBwb3J0ZWQuIEtlZXBpbmcgdGhpcyBoZXJlIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXMuXG4gICAgcG9seWZpbGxzLmhhcyhydWxlLmlkKSB8fFxuICAgIC8vIENoZWNrIGlmIHBvbHlmaWxsIGlzIHByb3ZpZGVkIChleC4gYFByb21pc2UuYWxsYClcbiAgICBwb2x5ZmlsbHMuaGFzKHJ1bGUucHJvdG9DaGFpbklkKSB8fFxuICAgIC8vIENoZWNrIGlmIGVudGlyZSBBUEkgaXMgcG9seWZpbGxlZCAoZXguIGBQcm9taXNlYClcbiAgICBwb2x5ZmlsbHMuaGFzKHJ1bGUucHJvdG9DaGFpblswXSlcbiAgKTtcbn1cblxuY29uc3QgZ2V0UnVsZXNGb3JUYXJnZXRzID0gbWVtb2l6ZSgodGFyZ2V0c0pTT046IHN0cmluZyk6IE9iamVjdCA9PiB7XG4gIGNvbnN0IHRhcmdldHMgPSBKU09OLnBhcnNlKHRhcmdldHNKU09OKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIENhbGxFeHByZXNzaW9uOiBbXSxcbiAgICBOZXdFeHByZXNzaW9uOiBbXSxcbiAgICBNZW1iZXJFeHByZXNzaW9uOiBbXVxuICB9O1xuICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgIGlmIChydWxlLmdldFVuc3VwcG9ydGVkVGFyZ2V0cyhydWxlLCB0YXJnZXRzKS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICByZXN1bHRbcnVsZS5hc3ROb2RlVHlwZV0ucHVzaChydWxlKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBtZXRhOiB7XG4gICAgZG9jczoge1xuICAgICAgZGVzY3JpcHRpb246ICdFbnN1cmUgY3Jvc3MtYnJvd3NlciBBUEkgY29tcGF0aWJpbGl0eScsXG4gICAgICBjYXRlZ29yeTogJ0NvbXBhdGliaWxpdHknLFxuICAgICAgdXJsOlxuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2FtaWxhamFjay9lc2xpbnQtcGx1Z2luLWNvbXBhdC9ibG9iL21hc3Rlci9kb2NzL3J1bGVzL2NvbXBhdC5tZCcsXG4gICAgICByZWNvbW1lbmRlZDogdHJ1ZVxuICAgIH0sXG4gICAgZml4YWJsZTogJ2NvZGUnLFxuICAgIHNjaGVtYTogW3sgdHlwZTogJ3N0cmluZycgfV1cbiAgfSxcbiAgY3JlYXRlKGNvbnRleHQ6IENvbnRleHQpOiBFU0xpbnQge1xuICAgIC8vIERldGVybWluZSBsb3dlc3QgdGFyZ2V0cyBmcm9tIGJyb3dzZXJzbGlzdCBjb25maWcsIHdoaWNoIHJlYWRzIHVzZXInc1xuICAgIC8vIHBhY2thZ2UuanNvbiBjb25maWcgc2VjdGlvbi4gVXNlIGNvbmZpZyBmcm9tIGVzbGludHJjIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgY29uc3QgYnJvd3NlcnNsaXN0Q29uZmlnOiBCcm93c2VyTGlzdENvbmZpZyA9XG4gICAgICBjb250ZXh0LnNldHRpbmdzLmJyb3dzZXJzIHx8XG4gICAgICBjb250ZXh0LnNldHRpbmdzLnRhcmdldHMgfHxcbiAgICAgIGNvbnRleHQub3B0aW9uc1swXTtcblxuICAgIGNvbnN0IGJyb3dzZXJzbGlzdFRhcmdldHMgPSBWZXJzaW9uaW5nKFxuICAgICAgRGV0ZXJtaW5lVGFyZ2V0c0Zyb21Db25maWcoY29udGV4dC5nZXRGaWxlbmFtZSgpLCBicm93c2Vyc2xpc3RDb25maWcpXG4gICAgKTtcblxuICAgIC8vIFN0cmluZ2lmeSB0byBzdXBwb3J0IG1lbW9pemF0aW9uOyBicm93c2Vyc2xpc3RDb25maWcgaXMgYWx3YXlzIGFuIGFycmF5IG9mIG5ldyBvYmplY3RzLlxuICAgIGNvbnN0IHRhcmdldGVkUnVsZXMgPSBnZXRSdWxlc0ZvclRhcmdldHMoXG4gICAgICBKU09OLnN0cmluZ2lmeShicm93c2Vyc2xpc3RUYXJnZXRzKVxuICAgICk7XG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUZhaWxpbmdSdWxlKHJ1bGU6IE5vZGUsIG5vZGU6IEVTTGludE5vZGUpIHtcbiAgICAgIGlmIChpc1BvbHlmaWxsZWQoY29udGV4dCwgcnVsZSkpIHJldHVybjtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbWVzc2FnZTogW1xuICAgICAgICAgIGdlbmVyYXRlRXJyb3JOYW1lKHJ1bGUpLFxuICAgICAgICAgICdpcyBub3Qgc3VwcG9ydGVkIGluJyxcbiAgICAgICAgICBydWxlLmdldFVuc3VwcG9ydGVkVGFyZ2V0cyhydWxlLCBicm93c2Vyc2xpc3RUYXJnZXRzKS5qb2luKCcsICcpXG4gICAgICAgIF0uam9pbignICcpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBpZGVudGlmaWVycyA9IG5ldyBTZXQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBDYWxsRXhwcmVzc2lvbjogbGludENhbGxFeHByZXNzaW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGhhbmRsZUZhaWxpbmdSdWxlLFxuICAgICAgICB0YXJnZXRlZFJ1bGVzLkNhbGxFeHByZXNzaW9uXG4gICAgICApLFxuICAgICAgTmV3RXhwcmVzc2lvbjogbGludE5ld0V4cHJlc3Npb24uYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgaGFuZGxlRmFpbGluZ1J1bGUsXG4gICAgICAgIHRhcmdldGVkUnVsZXMuTmV3RXhwcmVzc2lvblxuICAgICAgKSxcbiAgICAgIE1lbWJlckV4cHJlc3Npb246IGxpbnRNZW1iZXJFeHByZXNzaW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGhhbmRsZUZhaWxpbmdSdWxlLFxuICAgICAgICB0YXJnZXRlZFJ1bGVzLk1lbWJlckV4cHJlc3Npb25cbiAgICAgICksXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCB0aGUgZGVmaW5lZCB2YXJpYWJsZXMuIERvIG5vdCByZXBvcnQgZXJyb3JzIGZvciBub2RlcyB0aGF0IGFyZSBub3QgZGVmaW5lZFxuICAgICAgSWRlbnRpZmllcihub2RlOiBFU0xpbnROb2RlKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gZXguIGNvbnN0IHsgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcbiAgICAgICAgICAgIHR5cGUgPT09ICdQcm9wZXJ0eScgfHxcbiAgICAgICAgICAgIC8vIGV4LiBmdW5jdGlvbiBTZXQoKSB7fVxuICAgICAgICAgICAgdHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nIHx8XG4gICAgICAgICAgICAvLyBleC4gY29uc3QgU2V0ID0gKCkgPT4ge31cbiAgICAgICAgICAgIHR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InIHx8XG4gICAgICAgICAgICAvLyBleC4gY2xhc3MgU2V0IHt9XG4gICAgICAgICAgICB0eXBlID09PSAnQ2xhc3NEZWNsYXJhdGlvbicgfHxcbiAgICAgICAgICAgIC8vIGV4LiBpbXBvcnQgU2V0IGZyb20gJ3NldCc7XG4gICAgICAgICAgICB0eXBlID09PSAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicgfHxcbiAgICAgICAgICAgIC8vIGV4LiBpbXBvcnQge1NldH0gZnJvbSAnc2V0JztcbiAgICAgICAgICAgIHR5cGUgPT09ICdJbXBvcnRTcGVjaWZpZXInIHx8XG4gICAgICAgICAgICAvLyBleC4gaW1wb3J0IHtTZXR9IGZyb20gJ3NldCc7XG4gICAgICAgICAgICB0eXBlID09PSAnSW1wb3J0RGVjbGFyYXRpb24nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZGVudGlmaWVycy5hZGQobm9kZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnUHJvZ3JhbTpleGl0JzogKCkgPT4ge1xuICAgICAgICAvLyBHZXQgYSBtYXAgb2YgYWxsIHRoZSB2YXJpYWJsZXMgZGVmaW5lZCBpbiB0aGUgcm9vdCBzY29wZSAobm90IHRoZSBnbG9iYWwgc2NvcGUpXG4gICAgICAgIC8vIGNvbnN0IHZhcmlhYmxlc01hcCA9IGNvbnRleHQuZ2V0U2NvcGUoKS5jaGlsZFNjb3Blcy5tYXAoZSA9PiBlLnNldClbMF07XG4gICAgICAgIGVycm9yc1xuICAgICAgICAgIC5maWx0ZXIoZXJyb3IgPT4gIWlkZW50aWZpZXJzLmhhcyhnZXROYW1lKGVycm9yLm5vZGUpKSlcbiAgICAgICAgICAuZm9yRWFjaChub2RlID0+IGNvbnRleHQucmVwb3J0KG5vZGUpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuIl19