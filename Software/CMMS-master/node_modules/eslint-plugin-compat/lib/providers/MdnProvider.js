"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mdnSupported = mdnSupported;
exports.getUnsupportedTargets = getUnsupportedTargets;
exports.default = void 0;

var _astMetadataInferer = _interopRequireDefault(require("ast-metadata-inferer"));

var _semver = _interopRequireDefault(require("semver"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const mdnRecords = new Map(_astMetadataInferer.default.map(e => [e.protoChainId, e]));
/**
 * Map ids of mdn targets to their "common/friendly" name
 */

const targetNameMappings = {
  chrome: 'Chrome',
  firefox: 'Firefox',
  opera: 'Opera',
  safari: 'Safari',
  ie: 'IE',
  edge: 'Edge',
  safari_ios: 'iOS Safari',
  opera_android: 'Opera Mobile',
  chrome_android: 'Android Chrome',
  edge_mobile: 'Edge Mobile',
  firefox_android: 'Android Firefox',
  webview_android: 'WebView Android',
  samsunginternet_android: 'Samsung Browser',
  nodes: 'Node.js'
};
/**
 * Take a target's id and return it's full name by using `targetNameMappings`
 * ex. {target: and_ff, version: 40} => 'Android FireFox 40'
 */

function formatTargetNames(target) {
  return `${targetNameMappings[target.target]} ${target.version}`;
}
/**
 * Convert '9' => '9.0.0'
 */


function customCoerce(version) {
  return version.length === 1 ? [version, 0, 0].join('.') : version;
}
/*
 * Return if MDN supports the API or not
 */


function mdnSupported(node, {
  version,
  target
}) {
  // If no record could be found, return false. Rules might not
  // be found because they could belong to another provider
  if (!mdnRecords.has(node.protoChainId)) return true;
  const record = mdnRecords.get(node.protoChainId);
  if (!record || !record.compat.support) return true;
  const compatRecord = record.compat.support[target];
  if (!compatRecord) return true;
  if (!Array.isArray(compatRecord) && !('version_added' in compatRecord)) return true;
  const {
    version_added: versionAdded
  } = Array.isArray(compatRecord) ? compatRecord.find(e => 'version_added' in e) : compatRecord; // If a version is true then it is supported but version is unsure

  if (typeof versionAdded === 'boolean') return versionAdded;
  if (versionAdded === null) return true; // Special case for Safari TP: TP is always gte than any other releases

  if (target === 'safari') {
    if (version === 'TP') return true;
    if (versionAdded === 'TP') return false;
  } // A browser supports an API if its version is greater than or equal
  // to the first version of the browser that API was added in


  const semverCurrent = _semver.default.coerce(customCoerce(version));

  const semverAdded = _semver.default.coerce(customCoerce(versionAdded)); // semver.coerce() might be null for non-semvers (other than Safari TP)
  // Just warn and treat features as supported here for now to avoid lint from
  // crashing


  if (!semverCurrent) {
    // eslint-disable-next-line no-console
    console.warn(`eslint-plugin-compat: A non-semver target "${target} ${version}" matched for the feature ${node.protoChainId}, skipping. You're welcome to submit this log to https://github.com/amilajack/eslint-plugin-compat/issues for analysis.`);
    return true;
  }

  if (!versionAdded) {
    // eslint-disable-next-line no-console
    console.warn(`eslint-plugin-compat: The feature ${node.protoChainId} is supported since a non-semver target "${target} ${versionAdded}", skipping. You're welcome to submit this log to https://github.com/amilajack/eslint-plugin-compat/issues for analysis.`);
    return true;
  }

  return _semver.default.gte(semverCurrent, semverAdded);
}
/**
 * Return an array of all unsupported targets
 */


function getUnsupportedTargets(node, targets) {
  return targets.filter(target => !mdnSupported(node, target)).map(formatTargetNames);
}

function getMetadataName(metadata) {
  switch (metadata.protoChain.length) {
    case 1:
      {
        return metadata.protoChain[0];
      }

    default:
      return `${metadata.protoChain.join('.')}()`;
  }
}

const MdnProvider = _astMetadataInferer.default // Create entries for each ast node type
.map(metadata => metadata.astNodeTypes.map(astNodeType => _objectSpread({}, metadata, {
  name: getMetadataName(metadata),
  id: metadata.protoChainId,
  protoChainId: metadata.protoChainId,
  astNodeType,
  object: metadata.protoChain[0],
  // @TODO Handle cases where 'prototype' is in protoChain
  property: metadata.protoChain[1]
}))) // Flatten the array of arrays
.reduce((p, c) => [...p, ...c]) // Add rule and target support logic for each entry
.map(rule => _objectSpread({}, rule, {
  getUnsupportedTargets
}));

var _default = MdnProvider;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm92aWRlcnMvTWRuUHJvdmlkZXIuanMiXSwibmFtZXMiOlsibWRuUmVjb3JkcyIsIk1hcCIsIkFzdE1ldGFkYXRhIiwibWFwIiwiZSIsInByb3RvQ2hhaW5JZCIsInRhcmdldE5hbWVNYXBwaW5ncyIsImNocm9tZSIsImZpcmVmb3giLCJvcGVyYSIsInNhZmFyaSIsImllIiwiZWRnZSIsInNhZmFyaV9pb3MiLCJvcGVyYV9hbmRyb2lkIiwiY2hyb21lX2FuZHJvaWQiLCJlZGdlX21vYmlsZSIsImZpcmVmb3hfYW5kcm9pZCIsIndlYnZpZXdfYW5kcm9pZCIsInNhbXN1bmdpbnRlcm5ldF9hbmRyb2lkIiwibm9kZXMiLCJmb3JtYXRUYXJnZXROYW1lcyIsInRhcmdldCIsInZlcnNpb24iLCJjdXN0b21Db2VyY2UiLCJsZW5ndGgiLCJqb2luIiwibWRuU3VwcG9ydGVkIiwibm9kZSIsImhhcyIsInJlY29yZCIsImdldCIsImNvbXBhdCIsInN1cHBvcnQiLCJjb21wYXRSZWNvcmQiLCJBcnJheSIsImlzQXJyYXkiLCJ2ZXJzaW9uX2FkZGVkIiwidmVyc2lvbkFkZGVkIiwiZmluZCIsInNlbXZlckN1cnJlbnQiLCJzZW12ZXIiLCJjb2VyY2UiLCJzZW12ZXJBZGRlZCIsImNvbnNvbGUiLCJ3YXJuIiwiZ3RlIiwiZ2V0VW5zdXBwb3J0ZWRUYXJnZXRzIiwidGFyZ2V0cyIsImZpbHRlciIsImdldE1ldGFkYXRhTmFtZSIsIm1ldGFkYXRhIiwicHJvdG9DaGFpbiIsIk1kblByb3ZpZGVyIiwiYXN0Tm9kZVR5cGVzIiwiYXN0Tm9kZVR5cGUiLCJuYW1lIiwiaWQiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInJlZHVjZSIsInAiLCJjIiwicnVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7Ozs7Ozs7QUFxQkEsTUFBTUEsVUFBOEMsR0FBRyxJQUFJQyxHQUFKLENBQ3JEQyw0QkFBWUMsR0FBWixDQUFnQkMsQ0FBQyxJQUFJLENB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K0IsQ0FFOUJDLEdBRjhCLENBRTFCZ0QsUUFBUSxJQUNYQSxRQUFRLENBQUNHLFlBQVQsQ0FBc0JuRCxHQUF0QixDQUEwQm9ELFdBQVcsc0JBQ2hDSixRQURnQztBQUVuQ0ssRUFBQUEsSUFBSSxFQUFFTixlQUFlLENBQUNDLFFBQUQsQ0FGYztBQUduQ00sRUFBQUEsRUFBRSxFQUFFTixRQUFRLENBQUM5QyxZQUhzQjtBQUluQ0EsRUFBQUEsWUFBWSxFQUFFOEMsUUFBUSxDQUFDOUMsWUFKWTtBQUtuQ2tELEVBQUFBLFdBTG1DO0FBTW5DRyxFQUFBQSxNQUFNLEVBQUVQLFFBQVEsQ0FBQ0MsVUFBVCxDQUFvQixDQUFwQixDQU4yQjtBQU9uQztBQUNBTyxFQUFBQSxRQUFRLEVBQUVSLFFBQVEsQ0FBQ0MsVUFBVCxDQUFvQixDQUFwQjtBQVJ5QixFQUFyQyxDQUg2QixFQWMvQjtBQWQrQixDQWU5QlEsTUFmOEIsQ0FldkIsQ0FBQ0MsQ0FBRCxFQUFJQyxDQUFKLEtBQVUsQ0FBQyxHQUFHRCxDQUFKLEVBQU8sR0FBR0MsQ0FBVixDQWZhLEVBZ0IvQjtBQWhCK0IsQ0FpQjlCM0QsR0FqQjhCLENBaUIxQjRELElBQUksc0JBQ0pBLElBREk7QUFFUGhCLEVBQUFBO0FBRk8sRUFqQnNCLENBQWpDOztlQXNCZU0sVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBc3RNZXRhZGF0YSBmcm9tICdhc3QtbWV0YWRhdGEtaW5mZXJlcic7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgdHlwZSB7IE5vZGUsIFRhcmdldHMsIFRhcmdldCB9IGZyb20gJy4uL0xpbnRUeXBlcyc7XG5cbnR5cGUgQXN0TWV0YWRhdGFSZWNvcmRUeXBlID0ge1xuICBhcGlUeXBlOiAnanMtYXBpJyB8ICdjc3MtYXBpJyxcbiAgdHlwZTogJ2pzLWFwaScgfCAnY3NzLWFwaScsXG4gIHByb3RvQ2hhaW46IEFycmF5PHN0cmluZz4sXG4gIHByb3RvQ2hhaW5JZDogc3RyaW5nLFxuICBhc3ROb2RlVHlwZXM6IEFycmF5PHN0cmluZz4sXG4gIGlzU3RhdGljOiBib29sZWFuLFxuICBjb21wYXQ6IHtcbiAgICBzdXBwb3J0OiB7XG4gICAgICBbYnJvd3Nlck5hbWU6IHN0cmluZ106IHtcbiAgICAgICAgLy8gSWYgYSB2ZXJzaW9uIGlzIHRydWUgdGhlbiBpdCBpcyBzdXBwb3J0ZWQgYnV0IHZlcnNpb24gaXMgdW5zdXJlXG4gICAgICAgIHZlcnNpb25fYWRkZWQ6IHN0cmluZyB8IGJvb2xlYW5cbiAgICAgIH1cbiAgICB9LFxuICAgIFt4OiBzdHJpbmddOiBhbnlcbiAgfVxufTtcblxuY29uc3QgbWRuUmVjb3JkczogTWFwPHN0cmluZywgQXN0TWV0YWRhdGFSZWNvcmRUeXBlPiA9IG5ldyBNYXAoXG4gIEFzdE1ldGFkYXRhLm1hcChlID0+IFtlLnByb3RvQ2hhaW5JZCwgZV0pXG4pO1xuXG4vKipcbiAqIE1hcCBpZHMgb2YgbWRuIHRhcmdldHMgdG8gdGhlaXIgXCJjb21tb24vZnJpZW5kbHlcIiBuYW1lXG4gKi9cbmNvbnN0IHRhcmdldE5hbWVNYXBwaW5ncyA9IHtcbiAgY2hyb21lOiAnQ2hyb21lJyxcbiAgZmlyZWZveDogJ0ZpcmVmb3gnLFxuICBvcGVyYTogJ09wZXJhJyxcbiAgc2FmYXJpOiAnU2FmYXJpJyxcbiAgaWU6ICdJRScsXG4gIGVkZ2U6ICdFZGdlJyxcbiAgc2FmYXJpX2lvczogJ2lPUyBTYWZhcmknLFxuICBvcGVyYV9hbmRyb2lkOiAnT3BlcmEgTW9iaWxlJyxcbiAgY2hyb21lX2FuZHJvaWQ6ICdBbmRyb2lkIENocm9tZScsXG4gIGVkZ2VfbW9iaWxlOiAnRWRnZSBNb2JpbGUnLFxuICBmaXJlZm94X2FuZHJvaWQ6ICdBbmRyb2lkIEZpcmVmb3gnLFxuICB3ZWJ2aWV3X2FuZHJvaWQ6ICdXZWJWaWV3IEFuZHJvaWQnLFxuICBzYW1zdW5naW50ZXJuZXRfYW5kcm9pZDogJ1NhbXN1bmcgQnJvd3NlcicsXG4gIG5vZGVzOiAnTm9kZS5qcydcbn07XG5cbi8qKlxuICogVGFrZSBhIHRhcmdldCdzIGlkIGFuZCByZXR1cm4gaXQncyBmdWxsIG5hbWUgYnkgdXNpbmcgYHRhcmdldE5hbWVNYXBwaW5nc2BcbiAqIGV4LiB7dGFyZ2V0OiBhbmRfZmYsIHZlcnNpb246IDQwfSA9PiAnQW5kcm9pZCBGaXJlRm94IDQwJ1xuICovXG5mdW5jdGlvbiBmb3JtYXRUYXJnZXROYW1lcyh0YXJnZXQ6IFRhcmdldCk6IHN0cmluZyB7XG4gIHJldHVybiBgJHt0YXJnZXROYW1lTWFwcGluZ3NbdGFyZ2V0LnRhcmdldF19ICR7dGFyZ2V0LnZlcnNpb259YDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0ICc5JyA9PiAnOS4wLjAnXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbUNvZXJjZSh2ZXJzaW9uOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdmVyc2lvbi5sZW5ndGggPT09IDEgPyBbdmVyc2lvbiwgMCwgMF0uam9pbignLicpIDogdmVyc2lvbjtcbn1cblxuLypcbiAqIFJldHVybiBpZiBNRE4gc3VwcG9ydHMgdGhlIEFQSSBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1kblN1cHBvcnRlZChub2RlOiBOb2RlLCB7IHZlcnNpb24sIHRhcmdldCB9OiBUYXJnZXQpOiBib29sZWFuIHtcbiAgLy8gSWYgbm8gcmVjb3JkIGNvdWxkIGJlIGZvdW5kLCByZXR1cm4gZmFsc2UuIFJ1bGVzIG1pZ2h0IG5vdFxuICAvLyBiZSBmb3VuZCBiZWNhdXNlIHRoZXkgY291bGQgYmVsb25nIHRvIGFub3RoZXIgcHJvdmlkZXJcbiAgaWYgKCFtZG5SZWNvcmRzLmhhcyhub2RlLnByb3RvQ2hhaW5JZCkpIHJldHVybiB0cnVlO1xuICBjb25zdCByZWNvcmQgPSBtZG5SZWNvcmRzLmdldChub2RlLnByb3RvQ2hhaW5JZCk7XG4gIGlmICghcmVjb3JkIHx8ICFyZWNvcmQuY29tcGF0LnN1cHBvcnQpIHJldHVybiB0cnVlO1xuICBjb25zdCBjb21wYXRSZWNvcmQgPSByZWNvcmQuY29tcGF0LnN1cHBvcnRbdGFyZ2V0XTtcbiAgaWYgKCFjb21wYXRSZWNvcmQpIHJldHVybiB0cnVlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY29tcGF0UmVjb3JkKSAmJiAhKCd2ZXJzaW9uX2FkZGVkJyBpbiBjb21wYXRSZWNvcmQpKVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCB7IHZlcnNpb25fYWRkZWQ6IHZlcnNpb25BZGRlZCB9ID0gQXJyYXkuaXNBcnJheShjb21wYXRSZWNvcmQpXG4gICAgPyBjb21wYXRSZWNvcmQuZmluZChlID0+ICd2ZXJzaW9uX2FkZGVkJyBpbiBlKVxuICAgIDogY29tcGF0UmVjb3JkO1xuXG4gIC8vIElmIGEgdmVyc2lvbiBpcyB0cnVlIHRoZW4gaXQgaXMgc3VwcG9ydGVkIGJ1dCB2ZXJzaW9uIGlzIHVuc3VyZVxuICBpZiAodHlwZW9mIHZlcnNpb25BZGRlZCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gdmVyc2lvbkFkZGVkO1xuICBpZiAodmVyc2lvbkFkZGVkID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBTcGVjaWFsIGNhc2UgZm9yIFNhZmFyaSBUUDogVFAgaXMgYWx3YXlzIGd0ZSB0aGFuIGFueSBvdGhlciByZWxlYXNlc1xuICBpZiAodGFyZ2V0ID09PSAnc2FmYXJpJykge1xuICAgIGlmICh2ZXJzaW9uID09PSAnVFAnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodmVyc2lvbkFkZGVkID09PSAnVFAnKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQSBicm93c2VyIHN1cHBvcnRzIGFuIEFQSSBpZiBpdHMgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWxcbiAgLy8gdG8gdGhlIGZpcnN0IHZlcnNpb24gb2YgdGhlIGJyb3dzZXIgdGhhdCBBUEkgd2FzIGFkZGVkIGluXG4gIGNvbnN0IHNlbXZlckN1cnJlbnQgPSBzZW12ZXIuY29lcmNlKGN1c3RvbUNvZXJjZSh2ZXJzaW9uKSk7XG4gIGNvbnN0IHNlbXZlckFkZGVkID0gc2VtdmVyLmNvZXJjZShjdXN0b21Db2VyY2UodmVyc2lvbkFkZGVkKSk7XG5cbiAgLy8gc2VtdmVyLmNvZXJjZSgpIG1pZ2h0IGJlIG51bGwgZm9yIG5vbi1zZW12ZXJzIChvdGhlciB0aGFuIFNhZmFyaSBUUClcbiAgLy8gSnVzdCB3YXJuIGFuZCB0cmVhdCBmZWF0dXJlcyBhcyBzdXBwb3J0ZWQgaGVyZSBmb3Igbm93IHRvIGF2b2lkIGxpbnQgZnJvbVxuICAvLyBjcmFzaGluZ1xuICBpZiAoIXNlbXZlckN1cnJlbnQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBlc2xpbnQtcGx1Z2luLWNvbXBhdDogQSBub24tc2VtdmVyIHRhcmdldCBcIiR7dGFyZ2V0fSAke3ZlcnNpb259XCIgbWF0Y2hlZCBmb3IgdGhlIGZlYXR1cmUgJHtub2RlLnByb3RvQ2hhaW5JZH0sIHNraXBwaW5nLiBZb3UncmUgd2VsY29tZSB0byBzdWJtaXQgdGhpcyBsb2cgdG8gaHR0cHM6Ly9naXRodWIuY29tL2FtaWxhamFjay9lc2xpbnQtcGx1Z2luLWNvbXBhdC9pc3N1ZXMgZm9yIGFuYWx5c2lzLmBcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghdmVyc2lvbkFkZGVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgZXNsaW50LXBsdWdpbi1jb21wYXQ6IFRoZSBmZWF0dXJlICR7bm9kZS5wcm90b0NoYWluSWR9IGlzIHN1cHBvcnRlZCBzaW5jZSBhIG5vbi1zZW12ZXIgdGFyZ2V0IFwiJHt0YXJnZXR9ICR7dmVyc2lvbkFkZGVkfVwiLCBza2lwcGluZy4gWW91J3JlIHdlbGNvbWUgdG8gc3VibWl0IHRoaXMgbG9nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWlsYWphY2svZXNsaW50LXBsdWdpbi1jb21wYXQvaXNzdWVzIGZvciBhbmFseXNpcy5gXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gc2VtdmVyLmd0ZShzZW12ZXJDdXJyZW50LCBzZW12ZXJBZGRlZCk7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IG9mIGFsbCB1bnN1cHBvcnRlZCB0YXJnZXRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbnN1cHBvcnRlZFRhcmdldHMoXG4gIG5vZGU6IE5vZGUsXG4gIHRhcmdldHM6IFRhcmdldHNcbik6IEFycmF5PHN0cmluZz4ge1xuICByZXR1cm4gdGFyZ2V0c1xuICAgIC5maWx0ZXIodGFyZ2V0ID0+ICFtZG5TdXBwb3J0ZWQobm9kZSwgdGFyZ2V0KSlcbiAgICAubWFwKGZvcm1hdFRhcmdldE5hbWVzKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWV0YWRhdGFOYW1lKG1ldGFkYXRhOiBOb2RlKSB7XG4gIHN3aXRjaCAobWV0YWRhdGEucHJvdG9DaGFpbi5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IHtcbiAgICAgIHJldHVybiBtZXRhZGF0YS5wcm90b0NoYWluWzBdO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGAke21ldGFkYXRhLnByb3RvQ2hhaW4uam9pbignLicpfSgpYDtcbiAgfVxufVxuXG5jb25zdCBNZG5Qcm92aWRlcjogQXJyYXk8Tm9kZT4gPSBBc3RNZXRhZGF0YVxuICAvLyBDcmVhdGUgZW50cmllcyBmb3IgZWFjaCBhc3Qgbm9kZSB0eXBlXG4gIC5tYXAobWV0YWRhdGEgPT5cbiAgICBtZXRhZGF0YS5hc3ROb2RlVHlwZXMubWFwKGFzdE5vZGVUeXBlID0+ICh7XG4gICAgICAuLi5tZXRhZGF0YSxcbiAgICAgIG5hbWU6IGdldE1ldGFkYXRhTmFtZShtZXRhZGF0YSksXG4gICAgICBpZDogbWV0YWRhdGEucHJvdG9DaGFpbklkLFxuICAgICAgcHJvdG9DaGFpbklkOiBtZXRhZGF0YS5wcm90b0NoYWluSWQsXG4gICAgICBhc3ROb2RlVHlwZSxcbiAgICAgIG9iamVjdDogbWV0YWRhdGEucHJvdG9DaGFpblswXSxcbiAgICAgIC8vIEBUT0RPIEhhbmRsZSBjYXNlcyB3aGVyZSAncHJvdG90eXBlJyBpcyBpbiBwcm90b0NoYWluXG4gICAgICBwcm9wZXJ0eTogbWV0YWRhdGEucHJvdG9DaGFpblsxXVxuICAgIH0pKVxuICApXG4gIC8vIEZsYXR0ZW4gdGhlIGFycmF5IG9mIGFycmF5c1xuICAucmVkdWNlKChwLCBjKSA9PiBbLi4ucCwgLi4uY10pXG4gIC8vIEFkZCBydWxlIGFuZCB0YXJnZXQgc3VwcG9ydCBsb2dpYyBmb3IgZWFjaCBlbnRyeVxuICAubWFwKHJ1bGUgPT4gKHtcbiAgICAuLi5ydWxlLFxuICAgIGdldFVuc3VwcG9ydGVkVGFyZ2V0c1xuICB9KSk7XG5cbmV4cG9ydCBkZWZhdWx0IE1kblByb3ZpZGVyO1xuIl19